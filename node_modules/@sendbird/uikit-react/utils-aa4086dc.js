import { c as __spreadArray } from './tslib.es6-c2fb729e.js';
import { f as format } from './index-2d27aeef.js';
import { e as isReadMessage } from './index-776554c0.js';
import { SendingStatus } from '@sendbird/chat/message';

var scrollToRenderedMessage = function (scrollRef, initialTimeStamp, setIsScrolled) {
  var _a;
  try {
    var container = scrollRef.current;
    // scroll into the message with initialTimeStamp
    var element = (_a = container.querySelectorAll("[data-sb-created-at=\"".concat(initialTimeStamp, "\"]"))) === null || _a === void 0 ? void 0 : _a[0];
    if (element instanceof HTMLElement) {
      // Calculate the offset of the element from the top of the container
      var containerHeight = container.offsetHeight;
      var elementHeight = element.offsetHeight;
      var elementOffset = (containerHeight - elementHeight) / 2;
      // Set the scroll position of the container to bring the element to the middle
      container.scrollTop = element.offsetTop - elementOffset;
    }
  } catch (_b) {
    // do nothing
  } finally {
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
  }
};
/* eslint-disable default-param-last */
var scrollIntoLast = function (initialTry, scrollRef, setIsScrolled) {
  if (initialTry === void 0) {
    initialTry = 0;
  }
  var MAX_TRIES = 10;
  var currentTry = initialTry;
  if (currentTry > MAX_TRIES) {
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
    return;
  }
  try {
    var scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector('.sendbird-conversation__messages-padding');
    scrollDOM.scrollTop = scrollDOM.scrollHeight;
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
  } catch (error) {
    setTimeout(function () {
      scrollIntoLast(currentTry + 1, scrollRef, setIsScrolled);
    }, 500 * currentTry);
  }
};
var isOperator = function (groupChannel) {
  var myRole = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myRole;
  return myRole === 'operator';
};
var isDisabledBecauseFrozen = function (groupChannel) {
  var isFrozen = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen;
  return isFrozen && !isOperator(groupChannel);
};
var isDisabledBecauseMuted = function (groupChannel) {
  var myMutedState = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myMutedState;
  return myMutedState === 'muted';
};
var getAllEmojisMapFromEmojiContainer = function (emojiContainer) {
  var _a = emojiContainer.emojiCategories,
    emojiCategories = _a === void 0 ? [] : _a;
  var allEmojisMap = new Map();
  for (var categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {
    var emojis = emojiCategories[categoryIndex].emojis;
    for (var emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {
      var _b = emojis[emojiIndex],
        key = _b.key,
        url = _b.url;
      allEmojisMap.set(key, url);
    }
  }
  return allEmojisMap;
};
var getNicknamesMapFromMembers = function (members) {
  if (members === void 0) {
    members = [];
  }
  var nicknamesMap = new Map();
  for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {
    var _a = members[memberIndex],
      userId = _a.userId,
      nickname = _a.nickname;
    nicknamesMap.set(userId, nickname);
  }
  return nicknamesMap;
};
var getUniqueListBy = function (arr, key) {
  var entries = arr.map(function (item) {
    return [item[key], item];
  });
  return Array.from(new Map(entries).values());
};
var getUniqueListByMessageId = function (arr) {
  return getUniqueListBy(arr, 'messageId');
};
var sortByCreatedAt = function (messages) {
  return messages.sort(function (a, b) {
    return a.createdAt - b.createdAt;
  });
};
var mergeAndSortMessages = function (oldMessages, newMessages) {
  var lastOldMessage = oldMessages[oldMessages.length - 1];
  var firstNewMessage = newMessages[0];
  // If the last message of oldMessages is older than the first message of newMessages,
  // then we can safely append newMessages to oldMessages.
  if ((lastOldMessage === null || lastOldMessage === void 0 ? void 0 : lastOldMessage.createdAt) < (firstNewMessage === null || firstNewMessage === void 0 ? void 0 : firstNewMessage.createdAt)) {
    return __spreadArray(__spreadArray([], oldMessages, true), newMessages, true);
  }
  // todo: optimize this
  // If the last message of oldMessages is newer than the first message of newMessages,
  // then we need to merge the two arrays and sort them by createdAt.
  var mergedMessages = __spreadArray(__spreadArray([], oldMessages, true), newMessages, true);
  var unique = getUniqueListByMessageId(mergedMessages);
  return sortByCreatedAt(unique);
};
var getMessageCreatedAt = function (message) {
  return format(message.createdAt, 'p');
};
var isSameGroup = function (message, comparingMessage, currentChannel) {
  var _a, _b;
  if (!(message && comparingMessage && message.messageType && message.messageType !== 'admin' && comparingMessage.messageType && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== 'admin' && 'sender' in message && 'sender' in comparingMessage && message.createdAt && comparingMessage.createdAt && message.sender.userId && comparingMessage.sender.userId)) {
    return false;
  }
  return (message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus) && ((_a = message === null || message === void 0 ? void 0 : message.sender) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _b === void 0 ? void 0 : _b.userId) && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage) && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage);
};
var passUnsuccessfullMessages = function (allMessages, newMessage) {
  if ('sendingStatus' in newMessage && (newMessage.sendingStatus === SendingStatus.SUCCEEDED || newMessage.sendingStatus === SendingStatus.PENDING)) {
    var lastIndexOfSucceededMessage = allMessages.map(function (message) {
      if ('sendingStatus' in message && message.sendingStatus) return message.sendingStatus;
      return message.isAdminMessage() ? SendingStatus.SUCCEEDED : null;
    }).lastIndexOf(SendingStatus.SUCCEEDED);
    if (lastIndexOfSucceededMessage + 1 < allMessages.length) {
      var messages = __spreadArray([], allMessages, true);
      messages.splice(lastIndexOfSucceededMessage + 1, 0, newMessage);
      return messages;
    }
  }
  return __spreadArray(__spreadArray([], allMessages, true), [newMessage], false);
};
var pxToNumber = function (px) {
  if (typeof px === 'number') {
    return px;
  }
  if (typeof px === 'string') {
    var parsed = Number.parseFloat(px);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return null;
};
var isAboutSame = function (a, b, px) {
  return Math.abs(a - b) <= px;
};

export { scrollToRenderedMessage as a, pxToNumber as b, getNicknamesMapFromMembers as c, isDisabledBecauseFrozen as d, isDisabledBecauseMuted as e, isOperator as f, getAllEmojisMapFromEmojiContainer as g, isSameGroup as h, isAboutSame as i, mergeAndSortMessages as m, passUnsuccessfullMessages as p, scrollIntoLast as s };
//# sourceMappingURL=utils-aa4086dc.js.map
