'use strict';

var tslib_es6 = require('./tslib.es6-c74b513f.js');
var index$1 = require('./index-3448df64.js');
var index = require('./index-dbe8dd84.js');
var message = require('@sendbird/chat/message');

var scrollToRenderedMessage = function (scrollRef, initialTimeStamp, setIsScrolled) {
  var _a;
  try {
    var container = scrollRef.current;
    // scroll into the message with initialTimeStamp
    var element = (_a = container.querySelectorAll("[data-sb-created-at=\"".concat(initialTimeStamp, "\"]"))) === null || _a === void 0 ? void 0 : _a[0];
    if (element instanceof HTMLElement) {
      // Calculate the offset of the element from the top of the container
      var containerHeight = container.offsetHeight;
      var elementHeight = element.offsetHeight;
      var elementOffset = (containerHeight - elementHeight) / 2;
      // Set the scroll position of the container to bring the element to the middle
      container.scrollTop = element.offsetTop - elementOffset;
    }
  } catch (_b) {
    // do nothing
  } finally {
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
  }
};
/* eslint-disable default-param-last */
var scrollIntoLast = function (initialTry, scrollRef, setIsScrolled) {
  if (initialTry === void 0) {
    initialTry = 0;
  }
  var MAX_TRIES = 10;
  var currentTry = initialTry;
  if (currentTry > MAX_TRIES) {
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
    return;
  }
  try {
    var scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector('.sendbird-conversation__messages-padding');
    scrollDOM.scrollTop = scrollDOM.scrollHeight;
    setIsScrolled === null || setIsScrolled === void 0 ? void 0 : setIsScrolled(true);
  } catch (error) {
    setTimeout(function () {
      scrollIntoLast(currentTry + 1, scrollRef, setIsScrolled);
    }, 500 * currentTry);
  }
};
var isOperator = function (groupChannel) {
  var myRole = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myRole;
  return myRole === 'operator';
};
var isDisabledBecauseFrozen = function (groupChannel) {
  var isFrozen = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen;
  return isFrozen && !isOperator(groupChannel);
};
var isDisabledBecauseMuted = function (groupChannel) {
  var myMutedState = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.myMutedState;
  return myMutedState === 'muted';
};
var getAllEmojisMapFromEmojiContainer = function (emojiContainer) {
  var _a = emojiContainer.emojiCategories,
    emojiCategories = _a === void 0 ? [] : _a;
  var allEmojisMap = new Map();
  for (var categoryIndex = 0; categoryIndex < emojiCategories.length; categoryIndex += 1) {
    var emojis = emojiCategories[categoryIndex].emojis;
    for (var emojiIndex = 0; emojiIndex < emojis.length; emojiIndex += 1) {
      var _b = emojis[emojiIndex],
        key = _b.key,
        url = _b.url;
      allEmojisMap.set(key, url);
    }
  }
  return allEmojisMap;
};
var getNicknamesMapFromMembers = function (members) {
  if (members === void 0) {
    members = [];
  }
  var nicknamesMap = new Map();
  for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {
    var _a = members[memberIndex],
      userId = _a.userId,
      nickname = _a.nickname;
    nicknamesMap.set(userId, nickname);
  }
  return nicknamesMap;
};
var getUniqueListBy = function (arr, key) {
  var entries = arr.map(function (item) {
    return [item[key], item];
  });
  return Array.from(new Map(entries).values());
};
var getUniqueListByMessageId = function (arr) {
  return getUniqueListBy(arr, 'messageId');
};
var sortByCreatedAt = function (messages) {
  return messages.sort(function (a, b) {
    return a.createdAt - b.createdAt;
  });
};
var mergeAndSortMessages = function (oldMessages, newMessages) {
  var lastOldMessage = oldMessages[oldMessages.length - 1];
  var firstNewMessage = newMessages[0];
  // If the last message of oldMessages is older than the first message of newMessages,
  // then we can safely append newMessages to oldMessages.
  if ((lastOldMessage === null || lastOldMessage === void 0 ? void 0 : lastOldMessage.createdAt) < (firstNewMessage === null || firstNewMessage === void 0 ? void 0 : firstNewMessage.createdAt)) {
    return tslib_es6.__spreadArray(tslib_es6.__spreadArray([], oldMessages, true), newMessages, true);
  }
  // todo: optimize this
  // If the last message of oldMessages is newer than the first message of newMessages,
  // then we need to merge the two arrays and sort them by createdAt.
  var mergedMessages = tslib_es6.__spreadArray(tslib_es6.__spreadArray([], oldMessages, true), newMessages, true);
  var unique = getUniqueListByMessageId(mergedMessages);
  return sortByCreatedAt(unique);
};
var getMessageCreatedAt = function (message) {
  return index$1.format(message.createdAt, 'p');
};
var isSameGroup = function (message, comparingMessage, currentChannel) {
  var _a, _b;
  if (!(message && comparingMessage && message.messageType && message.messageType !== 'admin' && comparingMessage.messageType && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== 'admin' && 'sender' in message && 'sender' in comparingMessage && message.createdAt && comparingMessage.createdAt && message.sender.userId && comparingMessage.sender.userId)) {
    return false;
  }
  return (message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus) && ((_a = message === null || message === void 0 ? void 0 : message.sender) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sender) === null || _b === void 0 ? void 0 : _b.userId) && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage) && index.isReadMessage(currentChannel, message) === index.isReadMessage(currentChannel, comparingMessage);
};
var passUnsuccessfullMessages = function (allMessages, newMessage) {
  if ('sendingStatus' in newMessage && (newMessage.sendingStatus === message.SendingStatus.SUCCEEDED || newMessage.sendingStatus === message.SendingStatus.PENDING)) {
    var lastIndexOfSucceededMessage = allMessages.map(function (message$1) {
      if ('sendingStatus' in message$1 && message$1.sendingStatus) return message$1.sendingStatus;
      return message$1.isAdminMessage() ? message.SendingStatus.SUCCEEDED : null;
    }).lastIndexOf(message.SendingStatus.SUCCEEDED);
    if (lastIndexOfSucceededMessage + 1 < allMessages.length) {
      var messages = tslib_es6.__spreadArray([], allMessages, true);
      messages.splice(lastIndexOfSucceededMessage + 1, 0, newMessage);
      return messages;
    }
  }
  return tslib_es6.__spreadArray(tslib_es6.__spreadArray([], allMessages, true), [newMessage], false);
};
var pxToNumber = function (px) {
  if (typeof px === 'number') {
    return px;
  }
  if (typeof px === 'string') {
    var parsed = Number.parseFloat(px);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return null;
};
var isAboutSame = function (a, b, px) {
  return Math.abs(a - b) <= px;
};

exports.getAllEmojisMapFromEmojiContainer = getAllEmojisMapFromEmojiContainer;
exports.getNicknamesMapFromMembers = getNicknamesMapFromMembers;
exports.isAboutSame = isAboutSame;
exports.isDisabledBecauseFrozen = isDisabledBecauseFrozen;
exports.isDisabledBecauseMuted = isDisabledBecauseMuted;
exports.isOperator = isOperator;
exports.isSameGroup = isSameGroup;
exports.mergeAndSortMessages = mergeAndSortMessages;
exports.passUnsuccessfullMessages = passUnsuccessfullMessages;
exports.pxToNumber = pxToNumber;
exports.scrollIntoLast = scrollIntoLast;
exports.scrollToRenderedMessage = scrollToRenderedMessage;
//# sourceMappingURL=utils-9193a195.js.map
