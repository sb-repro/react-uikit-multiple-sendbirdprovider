'use strict';

var React = require('react');
var consts = require('./consts-f54b15c2.js');

function useDebounce(callback, delay) {
  var timeoutRef = React.useRef(null);
  React.useEffect(function () {
    // Cleanup the timeout on unmount
    return function () {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  function debounceFunction() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = setTimeout(function () {
      callback.apply(void 0, args);
    }, delay);
  }
  return debounceFunction;
}

var DELAY = 500;
function calcScrollBottom(scrollHeight, scrollTop) {
  return scrollHeight - scrollTop;
}
function useHandleOnScrollCallback(_a) {
  var hasMore = _a.hasMore,
    hasNext = _a.hasNext,
    onScroll = _a.onScroll,
    scrollRef = _a.scrollRef,
    setShowScrollDownButton = _a.setShowScrollDownButton;
  var scrollCb = React.useCallback(function () {
    var element = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;
    if (element == null) {
      return;
    }
    var scrollTop = element.scrollTop,
      scrollHeight = element.scrollHeight,
      clientHeight = element.clientHeight;
    // https://sendbird.atlassian.net/browse/SBISSUE-11759
    // the edge case where channel is inside a page that already has scroll
    // scrollintoView will move the whole page, which we dont want
    var scrollBottom = calcScrollBottom(scrollHeight, scrollTop);
    // even if there is more to fetch or not,
    // we still have to show the scroll to bottom button
    if (typeof setShowScrollDownButton === 'function') {
      setShowScrollDownButton(scrollHeight > scrollTop + clientHeight + 1);
    }
    if (hasMore && scrollTop < consts.SCROLL_BUFFER) {
      onScroll(function () {
        // sets the scroll position to the bottom of the new messages
        element.scrollTop = element.scrollHeight - scrollBottom;
      });
    }
    if (hasNext) {
      onScroll(function () {
        // sets the scroll position to the top of the new messages
        element.scrollTop = scrollTop - (scrollHeight - element.scrollHeight);
      });
    }
  }, [setShowScrollDownButton, hasMore, onScroll, scrollRef]);
  return useDebounce(scrollCb, DELAY);
}

exports.useDebounce = useDebounce;
exports.useHandleOnScrollCallback = useHandleOnScrollCallback;
//# sourceMappingURL=index-692ea6aa.js.map
